<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-11T13:46:04.447Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="http://example.com/2024/11/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2024/11/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2024-11-11T12:28:08.000Z</published>
    <updated>2024-11-11T13:46:04.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用C11模拟伪闭包实现session的生命周期"><a href="#利用C11模拟伪闭包实现session的生命周期" class="headerlink" title="利用C11模拟伪闭包实现session的生命周期"></a>利用C11模拟伪闭包实现session的生命周期</h2><p>tips:    std::map中的键值对元素由key和value两部分组成, map中的值自动按key排序, 如在下列代码中key为string类型的, 而value为一个智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::shared_ptr&lt;Session&gt;&gt; _sessions;</span><br></pre></td></tr></table></figure><h4 id="构造伪闭包的思路"><a href="#构造伪闭包的思路" class="headerlink" title="构造伪闭包的思路"></a>构造伪闭包的思路</h4><ol><li>利用智能指针被复制和使用引用计数加一的原理保证内存不会被回收  -&gt;</li><li>bind操作可以将值绑定在一个函数对象上生成新的函数对象, 如果将智能指针作为参数绑定给函数对象, 那么智能指针就能以值的方式被新的函数对象使用, 那么智能指针的生命周期就和新的函数对象一样, 从而达到延长生命周期的效果。</li></ol><p>以HandleWrite举例, 在bind时传递__self_shared指针增加引用次数, 这样_self_shared智能指针的引用周期就和async_write第二个参数(也就是asio要求的回调函数对象)的生命周期一致了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_max_len),</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们也要在第一次绑定读写回调函数的时候传入智能指针的值,但是要注意传入的方式，不能用两个智能指针管理同一块内存, 以下是错误用法;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_ptr</span>&lt;CSession&gt;(<span class="keyword">this</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shared_ptr(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数, 所以要使用shared_from_this()函数返回智能指针, 该智能指针和之前管理这片内存的智能指针共享引用次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用C11中的bind和智能指针模拟了go, js中的闭包功能, 保证在触发回调函数之前Session都是活的。同时还可以避免二次析构</p><p><strong>在网络编程中，一个请求处理可能涉及到异步操作，如接收数据、发送响应等。这些操作可能不会立即完成，而是在未来的某个时刻完成。如果会话对象的生命周期只依赖于函数调用栈，那么当函数返回时，会话对象可能会被销毁，导致正在进行的操作失败。通过将会话对象封装在智能指针中，并将其传递给异步回调函数，可以确保会话对象在所有相关操作完成之前不会被销毁。</strong></p><p>所以就是通过调用智能指针增加其引用次数, (什么时候智能指针引用次数减一? 函数结束的时候), 直到全部函数退出, 引用次数变为0, 智能指针就自动析构了, 然后Session不再存活?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用C11模拟伪闭包实现session的生命周期&quot;&gt;&lt;a href=&quot;#利用C11模拟伪闭包实现session的生命周期&quot; class=&quot;headerlink&quot; title=&quot;利用C11模拟伪闭包实现session的生命周期&quot;&gt;&lt;/a&gt;利用C11模拟伪闭包实现se</summary>
      
    
    
    
    
  </entry>
  
</feed>
